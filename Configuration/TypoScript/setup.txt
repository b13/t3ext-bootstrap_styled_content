# page = PAGE
# page {
# 	config.doktype = html5
# 	includeCSS.bootstrap = EXT:bootstrap_styled_content/Resources/Public/Contrib/Bootstrap/css/bootstrap.css
# 	10 = TEXT
# 	10.value = My Bootstrap
# 	20 < styles.content.get
# }


# ***************************************************************************
# Notice: "styles." (and "temp.") objects are UNSET after template parsing!
# Use "lib." for persisting storage of objects.
# ***************************************************************************

# Clear out any constants in this reserved room!
styles.content >

# get content
styles.content.get = CONTENT
styles.content.get {
	table = tt_content
	select.orderBy = sorting
	select.where = colPos=0
	select.languageField = sys_language_uid
}



# *********************************************************************
# "lib." objects are preserved from unsetting after template parsing
# *********************************************************************
# Creates persistent ParseFunc setup for non-HTML content. This is recommended to use (as a reference!)
lib.parseFunc {
	makelinks = 1
	makelinks.http.keep = {$styles.content.links.keep}
	makelinks.http.extTarget < lib.parseTarget
	makelinks.http.extTarget =
	makelinks.http.extTarget.override = {$styles.content.links.extTarget}
	makelinks.mailto.keep = path
	tags {
		link = TEXT
		link {
			current = 1
			typolink.parameter.data = parameters : allParams
			typolink.extTarget < lib.parseTarget
			typolink.extTarget =
			typolink.extTarget.override = {$styles.content.links.extTarget}
			typolink.target < lib.parseTarget
			typolink.target =
			typolink.target.override = {$styles.content.links.target}
			parseFunc.constants =1
		}
	}
	allowTags = {$styles.content.links.allowTags}
	denyTags = *
	sword = <span class="csc-sword">|</span>
	constants = 1

	nonTypoTagStdWrap.HTMLparser = 1
	nonTypoTagStdWrap.HTMLparser {
		keepNonMatchedTags = 1
		htmlSpecialChars = 2
	}
}


# Creates persistent ParseFunc setup for RTE content (which is mainly HTML) based on the "ts_css" transformation.
lib.parseFunc_RTE < lib.parseFunc
lib.parseFunc_RTE {
	//  makelinks >
	# Processing <table> and <blockquote> blocks separately
	externalBlocks = article, aside, blockquote, div, dd, dl, footer, header, nav, ol, section, table, ul
	externalBlocks {
		# The blockquote content is passed into parseFunc again...
		blockquote.stripNL=1
		blockquote.callRecursive=1
		blockquote.callRecursive.tagStdWrap.HTMLparser = 1
		blockquote.callRecursive.tagStdWrap.HTMLparser.tags.blockquote.overrideAttribs = style="margin-bottom:0;margin-top:0;"

		ol.stripNL=1
		ol.stdWrap.parseFunc = < lib.parseFunc

		ul.stripNL=1
		ul.stdWrap.parseFunc = < lib.parseFunc

		table.stripNL=1
		table.stdWrap.HTMLparser = 1
		table.stdWrap.HTMLparser.tags.table.fixAttrib.class {
			default = contenttable
			always = 1
			list = contenttable
		}
		table.stdWrap.HTMLparser.keepNonMatchedTags = 1
		table.HTMLtableCells=1
		table.HTMLtableCells {
			# Recursive call to self but without wrapping non-wrapped cell content
			default.stdWrap {
				parseFunc =< lib.parseFunc_RTE
				parseFunc.nonTypoTagStdWrap.encapsLines.nonWrappedTag = 
			}
			addChr10BetweenParagraphs=1
		}
		div.stripNL = 1
		div.callRecursive = 1

		article < .div
		aside < .div
		footer < .div
		header < .div
		nav < .div
		section < .div

		# Definition list processing
		dl < .div
		dd < .div
	}
	nonTypoTagStdWrap.encapsLines {
		encapsTagList = p,pre,h1,h2,h3,h4,h5,h6,hr,dt
		remapTag.DIV = P
		nonWrappedTag = P
		innerStdWrap_all.ifBlank = &nbsp;
	}
	nonTypoTagStdWrap.HTMLparser = 1
	nonTypoTagStdWrap.HTMLparser {
		keepNonMatchedTags = 1
		htmlSpecialChars = 2
	}
}








# Content header:
lib.stdheader = COA
lib.stdheader {

	# Create class attribute for <Hx> tags
	3 = LOAD_REGISTER
	3 {
		headerClass {
			cObject = COA
			cObject {
				# Create alignment class for <Hx> tags
				10 = TEXT
				10 {
					field = header_position
					required = 1
					noTrimWrap = |csc-header-alignment-| |
				}
				# Create "csc-firstHeader" class for <Hx> tags
				20 = TEXT
				20 {
					value = csc-firstHeader
					if {
						value = 1
						equals.data = cObj:parentRecordNumber
					}
				}
				stdWrap {
					trim = 1
					noTrimWrap = | class="|"|
					required = 1
				}
			}
		}
	}

	# Date format (not HTML5)
	5 = TEXT
	5 {
		field = date
		if {
			isTrue {
				field = date
			}
			isFalse = 1
			isFalse {
				if {
					value = html5
					equals.data = TSFE:config|config|doctype
				}
			}
		}
		strftime = %x
		wrap = <p class="csc-header-date">|</p>
		prefixComment = 2 | Header date:
	}

	# HTML5 <hgroup> open
	7 = TEXT
	7 {
		value = <hgroup>
		fieldRequired = subheader
		if {
			value = html5
			equals.data = TSFE:config|config|doctype
		}
	}

	# This CASE cObject renders the header content:
	# currentValue is set to the header data, possibly wrapped in link-tags.
	10 = CASE
	10.setCurrent {
		field = header
		htmlSpecialChars = 1
		typolink.parameter.field = header_link
	}
	10.key.field = header_layout
	10.key.ifEmpty = {$content.defaultHeaderType}
	10.key.ifEmpty.override.data = register: defaultHeaderType

	10.1 = TEXT
	10.1.current = 1
	10.1.dataWrap = <h1{register:headerClass}>|</h1>

	10.2 < .10.1
	10.2.dataWrap = <h2{register:headerClass}>|</h2>

	10.3 < .10.1
	10.3.dataWrap = <h3{register:headerClass}>|</h3>

	10.4 < .10.1
	10.4.dataWrap = <h4{register:headerClass}>|</h4>

	10.5 < .10.1
	10.5.dataWrap = <h5{register:headerClass}>|</h5>

	# HTML5 subheader
	20 = CASE
	20 {
		key {
			field = header_layout
		}

		default = TEXT
		default {
			wrap = <h2>|</h2>
			htmlSpecialChars = 1
			field = subheader
		}

		1 < .default

		2 < .default
		2.wrap = <h3>|</h3>

		3 < .default
		3.wrap = <h4>|</h4>

		4 < .default
		4.wrap = <h5>|</h5>

		5 < .default
		5.wrap = <h6>|</h6>

		if {
			isTrue {
				field = subheader
			}
			value = html5
			equals.data = TSFE:config|config|doctype
		}
	}

	# HTML5 <hgroup> close
	30 < lib.stdheader.7
	30 {
		value = </hgroup>
	}

	# HTML5 Date
	40 = COA
	40 {

		stdWrap {
			wrap = <p class="csc-header-date">|</p>
			innerWrap {
				cObject = COA
				cObject {
					10 = TEXT
					10 {
						value = <time
					}
					20 = TEXT
					20 {
						noTrimWrap = | datetime="|"|
						field = date
						strftime = %Y-%m-%d
					}
					30 = TEXT
					30 {
						value = >|</time>
					}
				}
			}
			required = 1
		}
		10 = TEXT
		10 {
			field = date
			strftime = %B %e, %Y
		}
		if {
			isTrue {
				field = date
			}
			value = html5
			equals.data = TSFE:config|config|doctype
		}
	}

	# Pops the used registers off the stack:
	98 = RESTORE_REGISTER

	# Post-processing:
	stdWrap.fieldRequired = header
	stdWrap.if {
		equals.field = header_layout
		value = 100
		negate = 1
	}

	stdWrap.editIcons = tt_content : header, [header_layout | header_position], [header_link|date]
	stdWrap.editIcons.beforeLastTag = 1
	stdWrap.editIcons.iconTitle.data = LLL:EXT:css_styled_content/pi1/locallang.xml:eIcon.header

	stdWrap {
		dataWrap = <div class="csc-header csc-header-n{cObj:parentRecordNumber}">|</div>
		dataWrap {
			override = <header class="csc-header csc-header-n{cObj:parentRecordNumber}">|</header>
			override {
				if {
					value = html5
					equals.data = TSFE:config|config|doctype
				}
			}
		}
	}
	stdWrap.prefixComment = 2 | Header:
}






